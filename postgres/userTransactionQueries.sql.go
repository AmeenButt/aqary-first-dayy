// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: userTransactionQueries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUserTransaction = `-- name: CreateUserTransaction :one
INSERT INTO user_transactions (
  user_wallet_id, transaction_amount, action
) VALUES (
  $1, $2, $3
)
RETURNING id, action, user_wallet_id, transaction_amount, created_at, updated_at
`

type CreateUserTransactionParams struct {
	UserWalletID      pgtype.Int4   `json:"user_wallet_id"`
	TransactionAmount pgtype.Float8 `json:"transaction_amount"`
	Action            string        `json:"action"`
}

func (q *Queries) CreateUserTransaction(ctx context.Context, arg CreateUserTransactionParams) (UserTransaction, error) {
	row := q.db.QueryRow(ctx, createUserTransaction, arg.UserWalletID, arg.TransactionAmount, arg.Action)
	var i UserTransaction
	err := row.Scan(
		&i.ID,
		&i.Action,
		&i.UserWalletID,
		&i.TransactionAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserTransaction = `-- name: DeleteUserTransaction :exec
DELETE FROM user_transactions
WHERE id = $1
`

func (q *Queries) DeleteUserTransaction(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUserTransaction, id)
	return err
}

const getUserWalletTransactions = `-- name: GetUserWalletTransactions :many
SELECT ut.id, action, user_wallet_id, transaction_amount, ut.created_at, ut.updated_at, us.id, user_id, amount, us.created_at, us.updated_at, u.id, name, email, password, profile_picture, u.created_at, u.updated_at FROM user_transactions ut JOIN user_wallet us ON ut.user_wallet_id = us.id JOIN users u ON us.user_id = u.id WHERE ut.user_wallet_id = $1
`

type GetUserWalletTransactionsRow struct {
	ID                int64            `json:"id"`
	Action            string           `json:"action"`
	UserWalletID      pgtype.Int4      `json:"user_wallet_id"`
	TransactionAmount pgtype.Float8    `json:"transaction_amount"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	ID_2              int64            `json:"id_2"`
	UserID            pgtype.Int4      `json:"user_id"`
	Amount            pgtype.Float8    `json:"amount"`
	CreatedAt_2       pgtype.Timestamp `json:"created_at_2"`
	UpdatedAt_2       pgtype.Timestamp `json:"updated_at_2"`
	ID_3              int64            `json:"id_3"`
	Name              string           `json:"name"`
	Email             pgtype.Text      `json:"email"`
	Password          pgtype.Text      `json:"password"`
	ProfilePicture    pgtype.Text      `json:"profile_picture"`
	CreatedAt_3       pgtype.Timestamp `json:"created_at_3"`
	UpdatedAt_3       pgtype.Timestamp `json:"updated_at_3"`
}

func (q *Queries) GetUserWalletTransactions(ctx context.Context, userWalletID pgtype.Int4) ([]GetUserWalletTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getUserWalletTransactions, userWalletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserWalletTransactionsRow{}
	for rows.Next() {
		var i GetUserWalletTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.UserWalletID,
			&i.TransactionAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.UserID,
			&i.Amount,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.ID_3,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.ProfilePicture,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT u.id, action, user_wallet_id, transaction_amount, u.created_at, u.updated_at, us.id, user_id, amount, us.created_at, us.updated_at FROM user_transactions u JOIN user_wallet us ON u.user_wallet_id = us.id ORDER BY u.id
`

type ListTransactionsRow struct {
	ID                int64            `json:"id"`
	Action            string           `json:"action"`
	UserWalletID      pgtype.Int4      `json:"user_wallet_id"`
	TransactionAmount pgtype.Float8    `json:"transaction_amount"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	ID_2              int64            `json:"id_2"`
	UserID            pgtype.Int4      `json:"user_id"`
	Amount            pgtype.Float8    `json:"amount"`
	CreatedAt_2       pgtype.Timestamp `json:"created_at_2"`
	UpdatedAt_2       pgtype.Timestamp `json:"updated_at_2"`
}

func (q *Queries) ListTransactions(ctx context.Context) ([]ListTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsRow{}
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.UserWalletID,
			&i.TransactionAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.UserID,
			&i.Amount,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
